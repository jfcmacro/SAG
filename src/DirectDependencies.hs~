module DirectDependencies(dp) where

import CFG
import AG
import qualified Data.Map  as Map
import qualified Data.List as List
import qualified Data.Set  as Set

dpBySemFunc :: ProdName -> SemFunc -> Map.Map AlphaAttr2 [AlphaAttr2]
dpBySemFunc pn (SF alpha _ beta) = foldl (Map.unionWith (++)) Map.empty [ Map.singleton  (fromAA2AA2 pn $ fromBetatoAlpha b) [(fromAA2AA2 pn a)]| a <- alpha, b <- beta, isPrAttr b]

dpSemFuncs :: ProdName -> SemFuncs -> (ProdName, Map.Map AlphaAttr2 [AlphaAttr2])
dpSemFuncs pn sfs = (pn, foldl (Map.unionWith (++)) Map.empty (map (dpBySemFunc pn) sfs))

dp :: Semantic -> [(ProdName, Map.Map AlphaAttr2 [AlphaAttr2])]
dp m = map (\(k,v) -> dpSemFuncs k v) $ Map.toList m

tc :: (Eq a) => [(a,a)] -> [(a,a)]
tc m = let itc mp = mp `List.union` [(a,d) | (a,b) <- mp, (c,d) <- mp, b == c]
           m' = itc m
       in if length m == length m'
          then m
          else tc m'

conv :: (Ord a) => Map.Map a [a] -> [(a,a)]
conv = concat.(map (\(x,xs) -> map (\x' -> (x,x')) xs)).(Map.toList)

conv' :: (Ord a) => [(b,Map.Map a [a])] -> [(a,a)]
conv' = foldl (\r (_,m) -> r `List.union` (conv m)) []

tcm :: (Ord a) => Map.Map a [a] -> Map.Map a a
tcm = (Map.fromList).tc.conv

pairSet :: [a] -> [[a]]
pairSet m = [[a,b] | a <- m, b <- m]

iter_idp_p :: Prods 
           -> ProdName
           -> [(AlphaAttr2,AlphaAttr2)] 
           -> [(AlphaAttr2,AlphaAttr2)] 
           -> [[AlphaAttr2]] 
           -> [(AlphaAttr2,AlphaAttr2)]
iter_idp_p prods p idp_0 idp_plus opr_p = 
    [(pia, pib) 
         | [pia@(AOut2 (AO2 _ i a )),pib@(AOut2 (AO2 _ i' b))] <- getIDPFromProdName p opr_p  
         , i == i'
         , (pja@(AOut2 (AO2 p2 j a')),pjb@(AOut2 (AO2 p2' j' b'))) <- idp_plus
         , p2 == p2' && j == j'
         , getNonTerminalPos p i prods == getNonTerminalPos p2 j prods
    ]

idp :: AG -> Map.Map ProdName (Map.Map AlphaAttr2 [AlphaAttr2])
idp ag = let a_dp     = dp $ sem ag
             a_idp_p0 = conv' a_dp
             idp_plus = tc a_idp_p0
             opr      = (pairSet.(Set.elems)) $ occurPR ag
             prodns   = getProdNames (cfg ag)
             a_idp_p1 = iter_idp_p prods' (prodns !! 0) a_idp_p0 a_idp_p0 opr 
             prods'   = prods.cfg $ ag
         in undefined


getIDPFromProdName :: ProdName -> [[AlphaAttr2]] -> [[AlphaAttr2]]
getIDPFromProdName p opr_p = 
    [[pia,pib] | [pia@(AOut2 (AO2 p' _ _)), pib@(AOut2 (AO2 p'' _ _))] <- opr_p
               , p == p' && p == p''
    ]




